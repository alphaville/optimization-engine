extern crate optimization_engine;

use icasadi;
use optimization_engine::{constraints::*, panoc::*, *};
use std::{num::NonZeroUsize, slice, time};

const TOLERANCE: f64 = {{solver_config.tolerance() or 0.0001}};
const LBFGS_MEMORY: usize = {{solver_config.lbfgs_memory() or 10}};
const MAX_ITERS: usize = {{solver_config.max_iterations() or 2000}};
const NU: usize = {{problem.dim_decision_variables()}};
const NP: usize = {{problem.dim_parameters()}};
const NCP: usize = {{problem.dim_constraints_penalty()}};
const NCAL: usize = {{problem.dim_constraints_aug_lagrangian()}};
{% if 'Ball2' == problem.constraints().__class__.__name__ and problem.constraints().center() is not none -%}
const XC: [f64; {{problem.dim_decision_variables()}}] = [{{problem.constraints().center()|join(', ')}}];
{%- endif -%}
{%- if 'Rectangle' == problem.constraints().__class__.__name__ -%}
    {%- if problem.constraints().xmin is not none -%}
const XMIN :Option<&[f64]> = Some(&[{{problem.constraints().xmin|join(', ')}}]);
    {%- else -%}
const XMIN :Option<&[f64]> = None;
    {%- endif -%}
    {% if problem.constraints().xmax is not none %}
const XMAX :Option<&[f64]> = Some(&[{{problem.constraints().xmax|join(', ')}}]);
    {%- else -%}
const XMAX :Option<&[f64]> = None;
    {% endif %}
{%- endif %}


pub fn initialize_solver() -> PANOCCache {
    let problem_size = NonZeroUsize::new(NU).unwrap();
    let lbfgs_memory_size = NonZeroUsize::new(LBFGS_MEMORY).unwrap();
    let panoc_cache = PANOCCache::new(problem_size, TOLERANCE, lbfgs_memory_size);

    panoc_cache
}


pub fn solve(p: &[f64], cache: &mut PANOCCache, u: &mut [f64]) -> SolverStatus {

	let df = |u: &[f64], grad: &mut [f64]| -> Result<(), Error> {
		icasadi::icasadi_grad(u, &p, grad);
		Ok(())
	};

	let f = |u: &[f64], c: &mut f64| -> Result<(), Error> {
		if icasadi::icasadi_cost(u, &p, c) == 0 {
		    Ok(())
		} else {
		    Err(Error::Cost)
		}
	};

    //Constraints...
{%- if problem.constraints() is none -%}
	let bounds = NoConstraints::new();
{%- endif %}
{%- if 'Ball2' == problem.constraints().__class__.__name__ -%}
  {% if problem.constraints().center() is none %}
	let bounds = Ball2::new(None, {{problem.constraints().radius()}});
  {% else %}
	let bounds = Ball2::new(Some(&XC), {{problem.constraints().radius()}});
  {% endif %}
{%- endif %}
{%- if 'Rectangle' == problem.constraints().__class__.__name__ %}
    let bounds = Rectangle::new(XMIN, XMAX);
{%- endif %}

	let problem = Problem::new(bounds, df, f);
    let mut panoc = PANOCOptimizer::new(problem, cache).with_max_iter(MAX_ITERS);
    let status = panoc.solve(u);

	status

}